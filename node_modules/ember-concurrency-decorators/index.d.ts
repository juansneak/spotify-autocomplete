import { TaskProperty as GenericTaskProperty, TaskGroupProperty as GenericTaskGroupProperty } from 'ember-concurrency';
export { default as lastValue } from './last-value';
declare type TaskProperty = GenericTaskProperty<unknown, unknown[]>;
declare type TaskGroupProperty = GenericTaskGroupProperty<unknown>;
declare type OptionsFor<T extends object> = {
    [K in OptionKeysFor<T>]?: OptionTypeFor<T, T[K]>;
};
declare type OptionKeysFor<T extends object> = {
    [K in keyof T]: OptionKeyFor<T, K, T[K]>;
}[keyof T];
declare type OptionKeyFor<T, K, F> = F extends (...args: any[]) => T ? K : never;
declare type OptionTypeFor<T, F> = F extends (...args: infer Args) => T ? Args[0] extends undefined ? true : Args[0] : never;
declare type MethodOrPropertyDecoratorWithParams<Params extends unknown[]> = MethodDecorator & PropertyDecorator & ((...params: Params) => MethodDecorator & PropertyDecorator);
/**
 * Turns the decorated generator function into a task.
 *
 * Optionally takes a hash of options that will be applied as modifiers to the
 * task. For instance `maxConcurrency`, `on`, `group` or `keepLatest`.
 *
 * ```js
 * import EmberObject from '@ember/object';
 * import { task } from 'ember-concurrency-decorators';
 *
 * class extends EmberObject {
 *   @task
 *   *plainTask() {}
 *
 *   @task({ maxConcurrency: 5, keepLatest: true, cancelOn: 'click' })
 *   *taskWithModifiers() {}
 * }
 * ```
 *
 * @function
 * @param {object?} [options={}]
 * @return {TaskProperty}
 */
export declare const task: MethodOrPropertyDecoratorWithParams<[OptionsFor<TaskProperty>]>;
/**
 * Turns the decorated generator function into a task and applies the
 * `restartable` modifier.
 *
 * Optionally takes a hash of further options that will be applied as modifiers
 * to the task.
 *
 * @function
 * @param {object?} [options={}]
 * @return {TaskProperty}
 */
export declare const restartableTask: MethodOrPropertyDecoratorWithParams<[OptionsFor<TaskProperty>]>;
/**
 * Turns the decorated generator function into a task and applies the
 * `drop` modifier.
 *
 * Optionally takes a hash of further options that will be applied as modifiers
 * to the task.
 *
 * @function
 * @param {object?} [options={}]
 * @return {TaskProperty}
 */
export declare const dropTask: MethodOrPropertyDecoratorWithParams<[OptionsFor<TaskProperty>]>;
/**
 * Turns the decorated generator function into a task and applies the
 * `keepLatest` modifier.
 *
 * Optionally takes a hash of further options that will be applied as modifiers
 * to the task.
 *
 * @function
 * @param {object?} [options={}]
 * @return {TaskProperty}
 */
export declare const keepLatestTask: MethodOrPropertyDecoratorWithParams<[OptionsFor<TaskProperty>]>;
/**
 * Turns the decorated generator function into a task and applies the
 * `enqueue` modifier.
 *
 * Optionally takes a hash of further options that will be applied as modifiers
 * to the task.
 *
 * @function
 * @param {object?} [options={}]
 * @return {TaskProperty}
 */
export declare const enqueueTask: MethodOrPropertyDecoratorWithParams<[OptionsFor<TaskProperty>]>;
/**
 * Turns the decorated property into a task group.
 *
 * Optionally takes a hash of options that will be applied as modifiers to the
 * task group. For instance `maxConcurrency` or `keepLatest`.
 *
 * ```js
 * import EmberObject from '@ember/object';
 * import { task taskGroup } from 'ember-concurrency-decorators';
 *
 * class extends EmberObject {
 *   @taskGroup({ maxConcurrency: 5 }) someTaskGroup;
 *
 *   @task({ group: 'someTaskGroup' })
 *   *someTask() {}
 *
 *   @task({ group: 'someTaskGroup' })
 *   *anotherTask() {}
 * }
 * ```
 *
 * @function
 * @param {object?} [options={}]
 * @return {TaskGroupProperty}
 */
export declare const taskGroup: MethodOrPropertyDecoratorWithParams<[OptionsFor<TaskGroupProperty>]>;
/**
 * Turns the decorated property into a task group and applies the
 * `restartable` modifier.
 *
 * Optionally takes a hash of further options that will be applied as modifiers
 * to the task group.
 *
 * @function
 * @param {object?} [options={}]
 * @return {TaskGroupProperty}
 */
export declare const restartableTaskGroup: MethodOrPropertyDecoratorWithParams<[OptionsFor<TaskGroupProperty>]>;
/**
 * Turns the decorated property into a task group and applies the
 * `drop` modifier.
 *
 * Optionally takes a hash of further options that will be applied as modifiers
 * to the task group.
 *
 * @function
 * @param {object?} [options={}]
 * @return {TaskGroupProperty}
 */
export declare const dropTaskGroup: MethodOrPropertyDecoratorWithParams<[OptionsFor<TaskGroupProperty>]>;
/**
 * Turns the decorated property into a task group and applies the
 * `keepLatest` modifier.
 *
 * Optionally takes a hash of further options that will be applied as modifiers
 * to the task group.
 *
 * @function
 * @param {object?} [options={}]
 * @return {TaskGroupProperty}
 */
export declare const keepLatestTaskGroup: MethodOrPropertyDecoratorWithParams<[OptionsFor<TaskGroupProperty>]>;
/**
 * Turns the decorated property into a task group and applies the
 * `enqueue` modifier.
 *
 * Optionally takes a hash of further options that will be applied as modifiers
 * to the task group.
 *
 * @function
 * @param {object?} [options={}]
 * @return {TaskGroupProperty}
 */
export declare const enqueueTaskGroup: MethodOrPropertyDecoratorWithParams<[OptionsFor<TaskGroupProperty>]>;
