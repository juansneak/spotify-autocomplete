/// <reference types="node" />
import Plugin from 'broccoli-plugin';
declare type Encoding = string;
export declare enum DuplicateStrategy {
    Prohibit = "prohibit",
    KeepFirst = "keep-first",
    KeepLast = "keep-last",
    KeepAll = "keep-all"
}
export declare type File = [string, any];
export declare type Entry = [number, string, string | Buffer];
declare type ProcessedEntry = [number, string, any];
declare type MergeReturnType = string | Buffer | [string, string | Buffer][];
interface Options {
    annotation?: string;
    patterns: string | string[];
    globOptions?: object;
    duplicates: DuplicateStrategy;
    encoding: Encoding;
    transformFile?(path: Entry[1], contents: Entry[2]): Promise<any> | any;
    sort: boolean | ((a: Entry, b: Entry) => number);
    merge(files: File[]): MergeReturnType | Promise<MergeReturnType>;
    outputFileName?: string;
}
declare type RequiredOptions = 'merge';
export declare class BroccoliMergeFiles extends Plugin {
    private options;
    constructor(inputNodes: Plugin.BroccoliNode[], options: Partial<Options> & Pick<Options, RequiredOptions>);
    build(): Promise<void>;
    readFiles(): Promise<Entry[]>;
    processFile(i: number, cwd: string, path: string): Promise<ProcessedEntry>;
    sort(entries: Entry[]): Entry[];
    deduplicate(entries: Entry[]): File[];
    writeOutput(merged: MergeReturnType): Promise<void>;
    writeOutputFile(fileName: string, contents: string | Buffer): Promise<void>;
}
export {};
//# sourceMappingURL=index.d.ts.map